{"meta":{"title":"lulu-blog","subtitle":"lulu","description":"blog for tec","author":"lulu","url":"https://luluminusone.github.io","root":"/"},"pages":[{"title":"categories","date":"2022-07-20T01:28:09.000Z","updated":"2022-07-21T05:49:50.588Z","comments":true,"path":"categories/index.html","permalink":"https://luluminusone.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-07-20T01:28:38.000Z","updated":"2022-07-20T01:29:16.009Z","comments":true,"path":"tags/index.html","permalink":"https://luluminusone.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"关于vue的笔记","slug":"vue","date":"2022-08-03T03:25:15.471Z","updated":"2022-08-10T02:33:20.157Z","comments":true,"path":"2022/08/03/vue/","link":"","permalink":"https://luluminusone.github.io/2022/08/03/vue/","excerpt":"","text":"关于vue的部署安装和使用文档的网址在这vue，然后写一写vue的学习笔录。 vue核心特性数据驱动（MVVM）MVVM指的是Model-View-ViewModelModel: 模型层：负责处理业务逻辑以及和服务器端进行交互。View: 视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面。ViewModel: 视图模型层：用来连接Model和View，是Model和View之间的通信桥梁。那就来创建一个简单实例简单讲解一下mvvm。 1234567891011121314&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; const app = vue.createApp(&#123; data() &#123; return &#123; message: &#x27;hello world&#x27; &#125; &#125;, template: `&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;` &#125;); const vm = app.mount(&#x27;#root&#x27;); //这里用vm起名也是方便理解为vue的各个根组件&lt;/script&gt; 在引入vue.js文件后，上面的代码就是一个简单的vue实例，可以这样理解，定义的数据message就是vue的model层，template就是vue的模板，也就是view层。将定义的数据（model）和模板（view）连接起来的就是ViewModel，那什么是ViewModel呢？ViewModel就是vue应用的各个根组件。ViewModel的作用是数据变化后更新视图，视图变化后更新数据。 生命周期函数所谓的生命周期函数指的是在某一时刻自动执行的函数。相对于vue来说可以分为四个阶段（生命周期）：1、初始化 &#x3D;&gt; 创建组件 &#x3D;&gt; beforeCreate created2、挂载 &#x3D;&gt; 渲染显示组件 &#x3D;&gt; beforeMount mounted3、更新 &#x3D;&gt; 修改了变量 &#x3D;&gt; 触发视图刷新 &#x3D;&gt; beforeUpdate updated4、销毁 &#x3D;&gt; 切换页面 &#x3D;&gt; 会把组件对象从内存删除 &#x3D;&gt; beforeDestroy destroyedvue生命周期函数图示 vue常用的指令v-model: 双向数据绑定指令v-if: 条件渲染指令v-for: 列表渲染指令v-bind: 属性绑定指令v-on: 事件绑定指令举个简单小例子 1234567891011121314151617181920212223242526272829todolist小案例&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; const app = vue.createApp(&#123; data() &#123; return &#123; inputValue: &#x27;&#x27;, list: [] &#125; &#125;, methods: &#123; handleAddItem() &#123; this.list.push(this.inputValue); this.inputValue = &#x27;&#x27;; //数据双向绑定 &#125; &#125;, template: ` &lt;div&gt; &lt;input v-model=&quot;inputValue&quot; /&gt; //数据双向绑定 &lt;button v-on:click=&quot;handleAddItem&quot;&gt;增加&lt;/button&gt; //事件绑定 &lt;ul&gt; &lt;li v-for=&quot;(item, index) of list&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; //列表遍历 &lt;/ul&gt; &lt;/div&gt; ` &#125;).mount(&#x27;#root&#x27;);&lt;/script&gt; 指令修饰符官方文档vue.js在文档里，有一些指令是有修饰符的，举个简单例子来写一下，具体有别的需求可以查看官方文档。 123v-on指令&lt;button @click.stop=&quot;doThis&quot;&gt;&lt;/button&gt;&lt;button @click.prevent=&quot;doThis&quot;&gt;&lt;/button&gt; computed计算属性和侦听器计算属性有缓存，提高渲染性能，若对现有的数据进行加工得到新数据，那就需要使用计算属性。计算属性的文档 1234567891011模板computed: &#123; &quot;属性名&quot;: &#123; set(值) &#123; &#125;, get() &#123; return &quot;值&quot; &#125; &#125;&#125; 侦听器文档侦听器可以监听数据（data&#x2F;computed等）的值的改变。实战当中深度监听可以这样写： 123456789watch: &#123; &quot;要监听的属性名&quot;: &#123; immediate: true, //立即执行 deep: true, //深度监听复杂类型内变化 handler (newVal, oldVal) &#123; &#125; &#125;&#125; 组件化vue组件文档用通俗的话去说的话，就是一个类似某东的网页，里面会有导航条，广告栏，轮播图，商品等等，从这里可以分为一个个的组件，比如说导航条组件，广告栏组件等等。其意思就是将各部分分开去书写代码，然后通过导出引入的方式去组成一个网页，这样如果出现报错或bug等等原因可以更有效定位去解决问题，提高了可维护性。组件分为全局组件和局部组件，先说全局组件。全局组件 12345678910111213141516171819&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; const app = Vue.createApp(&#123; template: ` &lt;div&gt; &lt;hello /&gt; &lt;world /&gt; &lt;/div&gt; `&#125;) app.component(&#x27;hello&#x27;, &#123; template: `&lt;div&gt;hello&lt;/div&gt;` &#125;) app.component(&#x27;world&#x27;, &#123; template: `&lt;div&gt;world&lt;/div&gt;` &#125;) const vm = app.mount(&#x27;#root&#x27;);&lt;/script&gt; 局部组件 1234567891011121314151617181920212223&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; const Hello = &#123; template: `&lt;div&gt;hello&lt;/div&gt;` &#125; const World = &#123; template: `&lt;div&gt;world&lt;/div&gt;` &#125; const app = Vue.createApp(&#123; components: &#123; hello: Hello, world: World &#125; template: ` &lt;div&gt; &lt;hello /&gt; &lt;world /&gt; &lt;/div&gt; `&#125;) const vm = app.mount(&#x27;#root&#x27;);&lt;/script&gt; 未完待续….","categories":[{"name":"编程","slug":"编程","permalink":"https://luluminusone.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"关于数组的常用方法和字符串的常用方法笔记","slug":"zengshangaicha","date":"2022-08-01T03:06:02.105Z","updated":"2022-08-02T01:52:52.583Z","comments":true,"path":"2022/08/01/zengshangaicha/","link":"","permalink":"https://luluminusone.github.io/2022/08/01/zengshangaicha/","excerpt":"","text":"对数组和字符串的增、删、改、查，四个字展开写一写。对数组增12345下面前三种是对原数组产生影响的增添方法，第四种则不会对原数组产生影响push()unshift()splice()concat() push()接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。 1234let colors = []; //创建数组let count = colors.push(&quot;red&quot;,&quot;green&quot;); //从数组末尾推入两项console.log(count); //2console.log(colors); //[&#x27;red&#x27;,&#x27;green&#x27;] unshift()在数组开头添加任意多个值，然后返回新的数组长度。 1234let colors = []; //创建数组let count = colors.unshift(&quot;red&quot;,&quot;green&quot;); //从数组开头推入两项console.log(count); //2console.log(colors); //[&#x27;red&#x27;,&#x27;green&#x27;] splice()传入三个参数，分别是开始位置、0（要删除的元素数量）、插入的元素，返回空数组。 1234let colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;];let removed = colors.splice(1, 0, &quot;black&quot;, &quot;pink&quot;);console.log(colors); //[&#x27;red&#x27;, &#x27;black&#x27;, &#x27;pink&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]console.log(removed) //[] concat()创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不影响原始数组。 1234let colors1 = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];let colors2 = colors1.concat(&quot;black&quot;, &quot;pink&quot;);console.log(colors1); //[&#x27;red&#x27;, &#x27;green&#x27;, &#x27;&#x27;blue]console.log(colors2); //[&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;black&#x27;, &#x27;pink&#x27;] 删12345下面前三种都会影响原数组，最后一项不影响原数组pop()shift()splice()slice() pop()删除数组的最后一项，同时减少数组的length值，返回被删除的项。 12345let colors = [&quot;red&quot;, &quot;green&quot;];let item = colors.pop();console.log(item); //greenconsole.log(colors.length); //1console.log(colors); //[&#x27;red&#x27;] shift()删除数组的第一项，同时减少数组的length值，返回被删除的项。 12345let colors = [&quot;red&quot;, &quot;green&quot;];let item = colors.shift();console.log(item); //redconsole.log(colors.length); //1console.log(colors); //[&#x27;green&#x27;] splice()传入两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组。 1234let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];let removed = colors.splice(0, 1); //删除第一项console.log(colors); //[&#x27;green&#x27;, &#x27;blue&#x27;]console.log(removed); //[&#x27;red&#x27;] slice()创建一个包含原有数组中一个或多个元素的新数组，不会影响原始数组。 123456let colors1 = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;];let colors2 = colors.slice(1);let colors3 = colors.slice(1, 4);console.log(colors1) // [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;, &#x27;yellow&#x27;, &#x27;purple&#x27;]concole.log(colors2); // [&#x27;green&#x27;, &#x27;blue&#x27;, &#x27;yellow&#x27;, &#x27;purple&#x27;]concole.log(colors3); // [&#x27;green&#x27;, &#x27;blue&#x27;, &#x27;yellow&#x27;] 改常用splice方法去修改数组的内容。 splice()传入三个参数，分别是开始位置，要删除元素的数量，要插入的任意多个元素，返回删除元素的数组，对原数组产生影响。 1234let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];let removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;); //插入两个值，删除一个元素console.log(colors); //[&#x27;red&#x27;, &#x27;red&#x27;, &#x27;purple&#x27;, &#x27;blue&#x27;]console.log(removed); //[&#x27;green&#x27;]，只有一个元素的数组 查1234查找元素，返回元素坐标或者元素值indexOf()includes()find() indexOf()返回要查找的元素在数组中的位置，如果没找到则返回 -1。 12let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];numbers.indexOf(4) //3 includes()返回要查找的元素在数组中的位置，找到返回true，否则false。 12let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];numbers.includes(4) //true find()返回第一个匹配的元素 1234567891011const people = [ &#123; name: &quot;alex&quot;, age: 18 &#125;, &#123; name: &quot;lulu&quot;, age: 20 &#125;];people.find((element, index, array) =&gt; element.age &lt; 19) // // &#123;name: &quot;alex&quot;, age: 18&#125; 对字符串有一点需要注意的是字符串创建了就不可变了，所以字符串的增、删、改都是创建字符串的副本去进行操作的。 增concat()用于将一个或多个字符串拼接成一个新字符串。 1234let stringValue = &quot;hello &quot;;let result = stringValue.concat(&quot;world&quot;);console.log(result); //&quot;hello world&quot;console.log(stringValue); //&quot;hello&quot; 删1234常用的方法slice()substr()substring() 12345678这三个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。let stringValue = &quot;hello world&quot;;console.log(stringValue.slice(3)); //&quot;lo world&quot;console.log(stringValue.substring(3)); //&quot;lo world&quot;console.log(stringValue.substr(3)); //&quot;lo world&quot;console.log(stringValue.slice(3, 7)); //&quot;lo w&quot;console.log(stringValue.substring(3, 7)); //&quot;lo w&quot;console.log(stringValue.substr(3, 7)); //&quot;lo worl&quot; 改12345常用的方法trim()、trimLeft()、trimRight()repeat()padStart()、padEnd()toLowerCase()、 toUpperCase() trim()、trimLeft()、trimRight()删除前、后或前后所有空格符，再返回新的字符串。 1234let stringValue = &quot;hello world&quot;;let trimmedStringValue = stringValue.trim();console.log(stringValue); //&quot;hello world&quot;console.log(trimmedStringValue); //&quot;hello world&quot; repeat()接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果。 12let stringValue = &quot;lu&quot;;let copyResult = stringValue.repeat(2) //lu lu padStart()复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。 123let stringValue = &quot;foo&quot;;console.log(stringValue.padStart(6)); // &quot; lu&quot;console.log(stringValue.padStart(9, &quot;.&quot;)); // &quot;.......lu&quot; toLowerCase()、 toUpperCase()大小写转化。 123let stringValue = &quot;hello world&quot;;console.log(stringValue.toUpperCase()); //&quot;HELLO WORLD&quot;console.log(stringValue.toLowerCase()); //&quot;hello world&quot; 查12345常用方法有chatAt()indexOf()startWith()includes() charAt()返回给定索引位置的字符，由传给方法的整数参数指定。 12let message = &quot;abcde&quot;;console.log(message.charAt(2)); //&quot;c&quot; indexOf()从字符串开头去搜索传入的字符串，并返回位置（如果没找到，则返回 -1 ）。 12let stringValue = &quot;hello world&quot;;console.log(stringValue.indexOf(&quot;o&quot;)); //4 startWith()、includes()从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。 12345let message = &quot;blackpink&quot;;console.log(message.startsWith(&quot;bla&quot;)); //trueconsole.log(message.startsWith(&quot;ack&quot;)); //falseconsole.log(message.includes(&quot;ckp&quot;)); //trueconsole.log(message.includes(&quot;lmn&quot;)); //false","categories":[{"name":"编程","slug":"编程","permalink":"https://luluminusone.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"关于正则表达式笔记","slug":"Rep","date":"2022-07-28T12:11:49.334Z","updated":"2022-08-01T02:55:50.461Z","comments":true,"path":"2022/07/28/Rep/","link":"","permalink":"https://luluminusone.github.io/2022/07/28/Rep/","excerpt":"","text":"正则表达式一般用于校验账号或者密码（密钥）的正确性，记录一下正则表达式的语法规则。 元字符1、\\d 匹配一个数字2、\\D 匹配一个非数字字符3、\\w 匹配一个单字字符（字母、数字或者下划线）4、\\W 匹配一个非单字字符5、\\s 匹配一个空白字符，包括空格、制表符和换行符6、. 任意字符7、^ 匹配开头8、$ 匹配结尾 元字符注意事项如果使用new RegExp()写法，反斜杠需多写一个，因为\\本身是转义字符。比如&#x2F;^\\d$&#x2F;和new RegExp(‘^\\d$’)是相同的意思。如果密钥规定有.或者#又或者其它符号，需要在前面加一个\\。 1234例子：/^.$/ 检查字符串是不是任意字符/^\\.$/ 检查字符串是不是一个点/^\\\\.$/ 检查字符串是不是一个反斜杠 方括号表示法可以使用短横-来指定一个字符范围，^表示否定。 12345元字符 等价的方括号表示法 \\d [0-9] \\D [^0-9] \\w [A-Za-z0-9_] \\W [^A-Za-z0-9_] 量词1234567量词 意义 * 匹配前一个表达式0次或多次。等价于&#123;0,&#125; + 匹配前面一个表达式1次或者多次。等价于&#123;1,&#125; ? 匹配前面一个表达式0次或者1次。等价于&#123;0,1&#125; &#123;n&#125; n是一个正整数，匹配了前面一个字符刚好出现了n次 &#123;n,&#125; n是一个正整数，匹配前一个字符至少出现了n次 &#123;n,m&#125; n和m都是整数，匹配前面的字符至少n次，最多m次 正则表达式的书写借着一些例子去讲解。例一： 1234检查银行卡密码是否六位数字var regexp1 = /^\\d&#123;6&#125;$/;var regexp2 = new RegExp(&#x27;^\\\\d&#123;6&#125;$&#x27;);这两个表达式是表示同样的意思。 例二： 123请验证某字符串是否是五位字母，大小写均可var str = &#x27;abcde&#x27;; //truevar regexp1 = /^[a-zA-Z]&#123;5&#125;$/ 例三： 1234请验证某字符串是否是4位小写字母，且最后一位不能是m字母var str1 = &#x27;abcd&#x27;; //truevar str2 = &#x27;abcm&#x27;; //falsevar regexp1 = /^[a-z]&#123;3&#125;[a-ln-z]$/ 最后一位不能为m，那么范围取a到l，n到z 例四： 12345请验证某字符串是否是这样的：以字母开头，中间是任意数字（最少1位）构成，并以字母结尾var str1 = &#x27;a564897b&#x27;; //truevar str2 = &#x27;abcd&#x27;; //falsevar str3 = &#x27;a1b&#x27;; //truevar regexp = /^[a-zA-Z]\\d+[a-zA-Z]$/; 例五： 12345请验证某字符串是否符合网址规则：以www.开头，中间是任意位的字符（字母数字下划线，最少一位，最后以.com结尾，也可以.com.cn结尾）var str1 = &#x27;www.abcd123.com&#x27;; //truevar str2 = &#x27;www.baidu.com&#x27;; //truevar str3 = &#x27;www.123aa&#x27; ; //falsevar regexp = /^www\\.\\w+\\.com(\\.cn)?$/; 有关于正则表达式大概先写，这么多，网上也有别人写好的正则表达式“轮子“,有需求可以直接查找即可。这一篇主要是熟悉一下基本的用法。","categories":[{"name":"编程","slug":"编程","permalink":"https://luluminusone.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"关于闭包笔记","slug":"bibao","date":"2022-07-27T01:18:47.896Z","updated":"2022-07-29T09:08:20.252Z","comments":true,"path":"2022/07/27/bibao/","link":"","permalink":"https://luluminusone.github.io/2022/07/27/bibao/","excerpt":"","text":"其实在javascript开发中会有一个不成文的规定吧，尽量少用全局变量，因为全局变量容易会污染环境，占内存等等，那么我们用闭包去进行私有化变量，先看下面的例子吧。 123456789function a() &#123; var name = &quot;alex&quot; function b() &#123; alert(name); &#125; return b;&#125;var c = a();c(); 从上面的例子我们可以大概知道闭包形成要有四个条件：1、有函数嵌套。2、内部函数引用外部作用域的变量参数。3、返回值是函数。4、创建一个对象函数，让其长期驻留。闭包的缺点是内存消耗大，如果滥用闭包会造成网页的性能问题，内存的泄露。在使用完闭包最好将局部变量全部删除，也就是等与null即可。（释放内存）。总的来说闭包就是创建私有变量，延长变量的生命周期。","categories":[{"name":"编程","slug":"编程","permalink":"https://luluminusone.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"关于原型链笔记","slug":"yuanxinglian","date":"2022-07-26T00:36:31.045Z","updated":"2022-07-28T09:14:01.398Z","comments":true,"path":"2022/07/26/yuanxinglian/","link":"","permalink":"https://luluminusone.github.io/2022/07/26/yuanxinglian/","excerpt":"","text":"什么是prototype任何函数都有prototype属性，prototype属性值是个对象，默认拥有constructor属性指回函数。构造函数的prototype属性是它的实例的原型。原型链的终点：数组的：","categories":[{"name":"编程","slug":"编程","permalink":"https://luluminusone.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"关于this笔记","slug":"this","date":"2022-07-25T00:39:37.729Z","updated":"2022-07-28T08:12:42.347Z","comments":true,"path":"2022/07/25/this/","link":"","permalink":"https://luluminusone.github.io/2022/07/25/this/","excerpt":"","text":"众所周知，函数中可以使用this关键字，它表示函数的上下文，那么上下文又是什么呢？举个例子：多吃水果，这会对身体好。（那么”这”指的是多吃水果）。回到我们的js函数里，可以这么理解，函数中的this具体指代什么东西，就需要通过调用函数时的上下文去判断了。this指向的规则下面我会举一些例子去说明。 规则一对象打点调用它的方法函数，则函数的上下文是这个打点的对象。对象.方法（）例子一： 123456789function fn() &#123; console.log(this.a + this.b);&#125;var obj = &#123; a: 1, b: 2, fn: fn&#125;;obj.fn(); //输出的结果为3，obj调用fn函数，this指向obj 例子二： 12345678910111213var obj1 = &#123; a: 1, b: 2, fn: function() &#123; console.log(this.a + this.b); &#125;&#125;;var obj2 = &#123; a: 3, b: 4, fn: obj1.fn&#125;;obj2.fn(); //输出的结果为7，obj2调用fn函数，this指向obj2 例子三： 123456789101112function outer() &#123; var a = 1; var b = 2; return &#123; a: 3, b: 4, fn: function () &#123; console.log(this.a + this.b); &#125; &#125;;&#125;outer().fn(); //输出的结果为7，调用outer函数，return一个对象，再调用fn函数，那么this指向对象里的a和b 规则二直接调用函数，则函数的上下文是window对象。函数（）例子一： 1234567891011var obj1 = &#123; a: 1, b: 2, fn: function () &#123; console.log(this.a + this.b); &#125;&#125;;var a = 3;var b = 4;var fn = obj1.fn;fn(); //输出结果为7，函数直接调用，则this指向window对象的a和b 例子二： 123456789101112function fun() &#123; return this.a + this.b;&#125;var a = 1;var b = 2;var obj = &#123; a: 3, b: fun(), //输出结果为3，直接调用函数，this指向window对象的a和b fn: fun&#125;;var result = obj.fun(); //输出结果为6，obj打点调用函数，this指向obj的a和bconsole.log(result); 规则三数组（类数组对象）枚举出函数进行调用，上下文是这个数组（类数组对象）。数组[下标]（）例子一： 1234var arr = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;,function () &#123; console.log(this[0]);&#125;];arr[3](); //输出结果为A,this指向arr数组的第0项 例子二： 123456function fun() &#123; arguments[3](); &#125;fun(&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, function () &#123; console.log(this[1]); //输出结果为B，this指向数组的第1项&#125;); 规则四在IIFE中的函数，上下文是window对象(function() { })(); 1234567891011var a = 1;var obj = &#123; a: 2, fun: (function () &#123; var a = this.a; return function () &#123; console.log(a + this.a); &#125; &#125;)() //IIFE函数中，this指向window，a = 1&#125;;obj.fun(); //输出结果为3，对象调用函数，this指向这个对象obj的a，a = 2 规则五定时器、延时器调用函数，上下文是window对象setInterval(函数，时间);setTimeout(函数，时间);例子一： 12345678910var obj = &#123; a: 1, b: 2, fun: function () &#123; console.log(this.a + this.b); &#125;&#125;var a = 3;var b = 4;setTimeout(obj.fun, 2000); //输出结果为7，定时器直接调用函数，this指向window的a和b 例子二： 123456789101112var obj = &#123; a: 1, b: 2, fun: function () &#123; console.log(this.a + this.b); &#125;&#125;var a = 3;var b = 4;setTimeout(function() &#123; obj.fun(); //输出结果为3，obj调用函数，this指向对象obj&#125;, 2000); 规则六事件处理函数的上下文是绑定事件的DOM元素DOM元素.onclick &#x3D; function () { };例子一： 123456789101112131415161718192021222324252627282930313233343536373839&lt;style&gt;#box1 &#123; float: left; border: 1px solid black; width: 99px; height: 99px; margin-right: 10px; &#125;#box2 &#123; float: left; border: 1px solid black; width: 99px; height: 99px; margin-right: 10px; &#125;#box3 &#123; float: left; border: 1px solid black; width: 99px; height: 99px; margin-right: 10px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;box2&quot;&gt;&lt;/div&gt; &lt;div id=&quot;box3&quot;&gt;&lt;/div&gt; &lt;script&gt; function setColorToRed() &#123; this.style.backgroundColor = &#x27;red&#x27;; &#125; var box1 = document.getElementById(&#x27;box1&#x27;); var box2 = document.getElementById(&#x27;box2&#x27;); var box3 = document.getElementById(&#x27;box3&#x27;); box1.onclick = setColorToRed; //this指向box1 box2.onclick = setColorToRed; //this指向box2 box3.onclick = setColorToRed; //this指向box3 &lt;/script&gt;&lt;/body&gt; 规则七箭头函数不会绑定this，也就是说箭头函数没有this，箭头函数在被申明确定this，这时它会直接将当前作用域的this作为自己的this例子一： 12345678910var name = &quot;alex&quot;var obj = &#123; name: &quot;bill&quot;, fun: () =&gt; &#123; console.log(this.name); &#125;&#125;var fun = obj.fun;obj.fun(); //输出为alexfun(); //输出为alex obj在创建时申明了箭头函数，箭头函数会寻找当前作用域，因obj是一个对象，并不是作用域，所以this指向window作用域例子二： 1234567891011121314var name = &quot;alex&quot;;var obj = &#123; name: &quot;bill&quot;, fun: function () &#123; return &#123; getName: () =&gt; &#123; console.log(this.myName); &#125; &#125; &#125;&#125;var fun = obj.fun().getName;obj.fun().getName(); //输出为billfun(); //输出为bill 首先箭头函数在obj.fun()的返回值申明的，this是fun()当前作用域的this，因被obj调用，所以this指向对象obj。fun()的结果输出为bill,原因var fun &#x3D; obj.fun().getName先执行obj.fun()，箭头函数被申明，那么this同样是fun()当前作用域的this，由于fun()是被obj调用的，所以this指向调用对象obj。 规则八在函数作用域里，严格模式下的this为undefined，若本身在全局作用域，this还是指向window。 this指向是可以改变的使用call、apply和bind函数可以修改this指向。 call修改this指向12345678910var obj = &#123; name: &quot;alex&quot;, fun: function(age,gender) &#123; console.log(`我系$&#123;this.name&#125;，今年$&#123;age&#125;岁，来自$&#123;gender&#125;`); &#125;&#125;var obj2 = &#123; name: &quot;lulu&quot;&#125;obj.fun.call(obj2, 18, &quot;广州南沙&quot;); call的第一个参数是手动指定this，所以this.name就指向obj2。 apply修改this指向12345678910var obj = &#123; name: &quot;alex&quot;, fun: function(age,gender) &#123; console.log(`我系$&#123;this.name&#125;，今年$&#123;age&#125;岁，来自$&#123;gender&#125;`); &#125;&#125;var obj2 = &#123; name: &quot;lulu&quot;&#125;obj.fun.apply(obj2, [18, &quot;广州南沙&quot;]); 同样的,apply第一个参数也是修改this指向，所以this.name指向obj2。 bind修改this指向1234567891011var obj = &#123; name: &quot;alex&quot;, fun: function(age,gender) &#123; console.log(`我系$&#123;this.name&#125;，今年$&#123;age&#125;岁，来自$&#123;gender&#125;`); &#125;&#125;var obj2 = &#123; name: &quot;lulu&quot;&#125;var fun1 = obj.fun.bind(obj2); //绑定this新函数fun1(18, &quot;广州南沙&quot;); //再次调用 bind与apply&#x2F;call有不同，前者不会立即执行，是返回一个绑定this新函数，需要再次调用才最终执行，而后者是立即执行的。","categories":[{"name":"编程","slug":"编程","permalink":"https://luluminusone.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"AnimateCss和Swiper插件","slug":"AnimateCss-Swiper","date":"2022-07-24T01:10:18.933Z","updated":"2022-07-26T05:44:44.455Z","comments":true,"path":"2022/07/24/AnimateCss-Swiper/","link":"","permalink":"https://luluminusone.github.io/2022/07/24/AnimateCss-Swiper/","excerpt":"","text":"关于Animate.cssAnimate.Css是一个开源的css动画库,这个动画库有在线演示，如果觉得哪个动画效果符合需求的话可以直接用，挺简单的。网站在这： Animate操作步骤:首先需要将Animate.css文件下载到电脑里面，下载地址：开源社区下载地址，官方下载地址。然后在你所需的页面引入css文件即可。 1234举个例子&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;animate.min.css&quot;&gt;&lt;/head&gt; 引入后，需要用该动画的元素添加类名就可以了。 12举个例子&lt;div class=&quot;animated fadeInUp&quot;&gt;&lt;/div&gt; 关于Swiper插件Swiper是一个开源、免费、强大的触摸滑动插件（官网这么说的~~）。这个插件可以实现移动端和PC端的大部分滑动功能，果然是非常强大！！这个插件的网址是：Swiper7。这个插件可以下载到本地引用其文件即可用，也可引用在线的文件去使用。使用方法在这：使用方法，我感觉我不用举例了，这里写得蛮详细的。基础演示效果在这：基础演示，大家根据自己想要的去调整代码就好。","categories":[{"name":"安利","slug":"安利","permalink":"https://luluminusone.github.io/categories/%E5%AE%89%E5%88%A9/"}],"tags":[]},{"title":"如何实现水平垂直居中","slug":"buju","date":"2022-07-23T02:15:33.216Z","updated":"2022-07-25T03:55:12.998Z","comments":true,"path":"2022/07/23/buju/","link":"","permalink":"https://luluminusone.github.io/2022/07/23/buju/","excerpt":"","text":"对于如何实现元素的水平垂直居中有以下的几种实现方法，供学习。 利用定位和margin:auto12345678910111213141516171819202122&lt;style&gt; .father &#123; width: 500px; height: 300px; background-color: #000; position: relative; &#125; .son &#123; width: 50px; height: 50px; background: red; position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto; &#125;&lt;/style&gt;&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt; 利用定位和margin负值123456789101112131415161718192021&lt;style&gt; .father &#123; width: 500px; height: 300px; background-color: #000; position: relative; &#125; .son &#123; width: 50px; height: 50px; background: red; position: absolute; top: 50%; left: 50%; margin-top: -25px; margin-left: -25px; &#125;&lt;/style&gt;&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt; 利用定位和CSS3属性1234567891011121314151617181920&lt;style&gt; .father &#123; width: 500px; height: 300px; background-color: #000; position: relative; &#125; .son &#123; width: 50px; height: 50px; background: red; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); //translate(x,y); &#125;&lt;/style&gt;&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt; 利用flex布局123456789101112131415161718&lt;style&gt; .father &#123; width: 500px; height: 300px; background-color: #000; display: flex; justify-content: center; align-items: center; &#125; .son &#123; width: 50px; height: 50px; background: red; &#125;&lt;/style&gt;&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt; 利用grid布局123456789101112131415161718&lt;style&gt; .father &#123; width: 500px; height: 300px; background-color: #000; display: grid; justify-content: center; align-items: center; &#125; .son &#123; width: 50px; height: 50px; background: red; &#125;&lt;/style&gt;&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;","categories":[{"name":"编程","slug":"编程","permalink":"https://luluminusone.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"轮播图的实现","slug":"how-to-create-carousel-figure","date":"2022-07-22T01:58:23.337Z","updated":"2022-07-25T02:33:18.458Z","comments":true,"path":"2022/07/22/how-to-create-carousel-figure/","link":"","permalink":"https://luluminusone.github.io/2022/07/22/how-to-create-carousel-figure/","excerpt":"","text":"今天是写一下关于轮播图的实现思路以及代码。 Html代码12345678910111213141516171819&lt;div class=&quot;banner&quot; id=&quot;banner&quot;&gt; &lt;ul id=&quot;carousel_list&quot; class=&quot;carousel_list&quot;&gt; &lt;li&gt;&lt;img src=&quot;images/beijing/0.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/beijing/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/beijing/2.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/beijing/3.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/beijing/4.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;leftbtn iconfont&quot; id=&quot;left_btn&quot;&gt;&amp;#xe659;&lt;/a&gt; //引用图标 &lt;a href=&quot;javascript:;&quot; class=&quot;rightbtn iconfont&quot; id=&quot;right_btn&quot;&gt;&amp;#xe658;&lt;/a&gt; //引用图标 &lt;ol class=&quot;circles&quot; id=&quot;circle_ol&quot;&gt; &lt;li data-n=&quot;0&quot; class=&quot;current&quot;&gt;&lt;/li&gt; //给current类名，后续用js实现点击某个小圆点变换颜色和图片 &lt;li data-n=&quot;1&quot;&gt;&lt;/li&gt; &lt;li data-n=&quot;2&quot;&gt;&lt;/li&gt; &lt;li data-n=&quot;3&quot;&gt;&lt;/li&gt; &lt;li data-n=&quot;4&quot;&gt;&lt;/li&gt; &lt;/ol&gt;&lt;/div&gt;PS:后面代码看不清的话可以鼠标左键点击一下代码区，用键盘的左右方向键滑动一下即可看到。 简单剖析一下html的布局，首先，要实现轮播图，我们可以定义一个div盒子，里面包裹着走马灯轮播图、左右切换轮播图的按钮和点击轮播图用的小圆点。逐个进行分析，对于走马灯区域我们会想到用一个无序列表去装我们的轮播图片，当然您也可以用一个div盒子里面包裹着span标签去装轮播图，以上只是我自己的一个实现方式。对于左右切换的按钮我们直接用 a 标签即可,还有我这里用了阿里巴巴的图标库，在CSS代码最上的那片代码是引用代码，有想了解如何引用iconfont图标的可以点这里iconfont。最后是点击某个小圆点能切换到对应的轮播图的实现，其实现方式可以用一个有序列表去实现，就如上面代码一样。这样html的布局就完成了。其实你有更好的想法也可按你自己的去写，怎么喜欢怎么来，轮播图实现有很多种方式。 CSS代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374@font-face &#123; font-family: &#x27;iconfont&#x27;; src: url(&#x27;./icon/iconfont.woff2?t=1658476720236&#x27;) format(&#x27;woff2&#x27;), url(&#x27;./icon/iconfont.woff?t=1658476720236&#x27;) format(&#x27;woff&#x27;), url(&#x27;./icon/iconfont.ttf?t=1658476720236&#x27;) format(&#x27;truetype&#x27;); &#125; .iconfont &#123; font-family: &quot;iconfont&quot; !important; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; &#125; *&#123; margin: 0; padding: 0; &#125; .banner &#123; width: 650px; height: 360px; border: 1px solid #000; margin: 50px auto; position: relative; overflow: hidden; //浮动起来的图片隐藏 &#125; .banner ul &#123; display: flex; //flex布局实现浮动 list-style: none; width: 100%; position: relative; left: 0; transition: left .5s ease 0s; //轮播图过渡效果 &#125; .banner .leftbtn &#123; text-decoration: none; position: absolute; left: 20px; top: 50%; margin-top: -15px; font-size: 40px; &#125; .banner .rightbtn &#123; text-decoration: none; //去掉下划线 position: absolute; right: 20px; top: 50%; font-size: 40px; margin-top: -15px; &#125; .banner .circles &#123; list-style: none; display: flex; //flex布局实现浮动 position: absolute; left: 50%; transform: translateX(-50%); //css3实现居中的写法 width: 150px; height: 20px; margin-top: -30px; &#125; .banner .circles li &#123; width: 20px; height: 20px; background-color: orange; margin-right: 10px; border-radius: 50%; cursor: pointer; &#125; .banner .circles li:last-child &#123; margin-right: 0; //最后一个小圆点取消margin-right &#125; .banner .circles .current &#123; background-color: purple; //点击某个小圆点会变色 &#125;PS:后面代码看不清的话可以鼠标左键点击一下代码区，用键盘的左右方向键滑动一下即可看到。 样式的话就按自己喜欢的来设定就好了，定位这些子绝父相大家应该都挺熟的，图片浮动和小圆点浮动我用了flex布局的一些知识，位置居中可用left: 50%,margin-left: -自身width的一半去实现水平居中，上下居中同理。上面有一些代码我也用了css3的属性去实现位置的居中。 JS代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 //获取元素 const banner = document.getElementById(&#x27;banner&#x27;); const carousel_list = document.getElementById(&#x27;carousel_list&#x27;); const left_btn = document.getElementById(&#x27;left_btn&#x27;); const right_btn = document.getElementById(&#x27;right_btn&#x27;); const circle_ol = document.getElementById(&#x27;circle_ol&#x27;); const circle_lis = circle_ol.getElementsByTagName(&#x27;li&#x27;); const clone_li = carousel_list.firstElementChild.cloneNode(true); //克隆第一个li carousel_list.appendChild(clone_li); //上树 let idx = 0; //当前显示图片序号 let lock = true; //定义节流锁 right_btn.onclick = function () &#123; //右按钮事件监听 if (!lock) return; //判断节流锁状态 lock = false; //关锁 carousel_list.style.transition = &#x27;transform .5s ease 0s&#x27;; //过渡 idx++; //idx + 1 carousel_list.style.transform = &#x27;translateX(&#x27; + -100 * idx + &#x27;%)&#x27;; //拉动图片 if (idx &gt; 4) &#123; //判断图片是否最后一张，是则需瞬间移动到第一张 setTimeout(function () &#123; carousel_list.style.transition = &#x27;none&#x27;; //去掉过渡 carousel_list.style.transform = &#x27;none&#x27;; //删除transform idx = 0; //图片序号变为0 &#125;, 500); &#125; setCircles(); //调用小圆点 setTimeout(function () &#123; //动画结束后开锁 lock = true; &#125;, 500); &#125; left_btn.onclick = function () &#123; //左按钮事件监听 if (!lock) return; //判断节流锁状态 lock = false; //关锁 if (idx === 0) &#123; //判断图片是否为第一张，是则需瞬间移动到最后一张 carousel_list.style.transition = &#x27;none&#x27;; //取消过渡 carousel_list.style.transform = &#x27;translateX(&#x27; + -100 * 5 + &#x27;%)&#x27;; //拉到最后（瞬间移动） idx = 4; //图片序号变为4 setTimeout(function () &#123; //0毫秒延时器，将瞬移后的过渡属性加上 carousel_list.style.transition = &#x27;transform .5s ease 0s&#x27;; //加上过渡 carousel_list.style.transform = &#x27;translateX(&#x27; + -100 * 4 + &#x27;%)&#x27;; &#125;, 0); &#125; else &#123; idx--; carousel_list.style.transform = &#x27;translateX(&#x27; + -100 * idx + &#x27;%)&#x27;; //拉动图片 &#125; setCircles(); //调用小圆点 setTimeout(function () &#123; //动画结束后开锁 lock = true; &#125;, 500); &#125; function setCircles() &#123; for (let i = 0; i &lt;= 4; i++) &#123; //遍历小圆点 if (i === idx % 5) &#123; //判断i是否等于idx，是则加上&#x27;current&#x27;类名 circle_lis[i].className = &#x27;current&#x27;; &#125; else &#123; circle_lis[i].className = &#x27;&#x27;; //类名为空 &#125; &#125; &#125; circle_ol.onclick = function (e) &#123; //事件委托，小圆点的监听 if (e.target.tagName.toLowerCase() === &#x27;li&#x27;) &#123; let n = Number(e.target.getAttribute(&#x27;data-n&#x27;)); //得到li身上的data-n属性 idx = n; //改变idx carousel_list.style.transition = &#x27;transform .5s ease 0s&#x27;; //过渡 carousel_list.style.transform = &#x27;translateX(&#x27; + -100 * idx + &#x27;%)&#x27;; //拉动图片 setCircles(); 调用小圆点 &#125; &#125; let timer = setInterval(right_btn_handler, 2000); //定时器，自动轮播 banner.onmouseenter = function () &#123; //鼠标进入暂停自动轮播 clearInterval(timer); &#125; banner.onmouseleave = function () &#123; //鼠标离开开始自动轮播 clearInterval(timer); //设表先关 timer = setInterval(right_btn_handler, 2000); &#125;PS:后面代码看不清的话可以鼠标左键点击一下代码区，用键盘的左右方向键滑动一下即可看到。 获取dom元素，左右按钮点击事件的监听，小圆点按钮点击事件监听，自动轮播和暂停轮播，在代码区中有注释如何实现，供参考。","categories":[{"name":"编程","slug":"编程","permalink":"https://luluminusone.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"git常用指令","slug":"git-command","date":"2022-07-21T07:48:38.109Z","updated":"2022-07-21T08:51:28.615Z","comments":true,"path":"2022/07/21/git-command/","link":"","permalink":"https://luluminusone.github.io/2022/07/21/git-command/","excerpt":"","text":"用于记录git常用的指令 代码提交使用一次新的commit，替代上一次提交，如果代码没有任何新变化，则用来改写上一次commit的提交信息1$ git commit --amend -m [message] 这个方法可以用来修改上次commit的备注信息 1$ git commit --amend 进入编辑模式，可将需要修改commit的记录的pick修改成edit，编辑好之后使用:wq保存退出。然后使用以下命令 1$ git commit --amend 进入编辑模式编辑commit 1$ git rebase --continue 分支列出所有远程分支1$ git branch -r 列出所有本地分支和远程分支1$ git branch -a 新建一个分支，但依然停留在当前分支1$ git branch [branch-name] 新建一个分支，指向指定commit1$ git branch [branch] [commit] 新建一个分支，与指定的远程分支建立追踪关系1$ git branch --track [branch] [remote-branch] 选择一个commit，合并进当前分支1$ git cherry-pick [commit] 删除分支(删除本地分支)1$ git branch -d [branch-name] 删除远程分支123$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签新建一个tag在当前commit1$ git tag [tag] 新建一个tag在指定commit1$ git tag [tag] [commit] 删除本地tag1$ git tag -d [tag] 删除远程tag1$ git push origin :refs/tags/[tagName] 查看tag信息1$ git show [tag] 提交指定tag1$ git push [remote] [tag] 提交所有tag1$ git push [remote] --tags 新建一个分支，指向某个tag1$ git checkout -b [branch] [tag] 查看信息显示commit历史，以及每次commit发生变更的文件1$ git log --stat 搜索提交历史，根据关键词1$ git log -S [keyword] 显示所有提交过的用户，按提交次数排序1$ git shortlog -sn 显示暂存区和工作区的差异1$ git diff 显示暂存区和上一个commit的差异1$ git diff --cached [file] 显示工作区与当前分支最新commit之间的差异1$ git diff HEAD 远程同步下载远程仓库的所有变动1$ git fetch [remote] 推送所有分支到远程仓库1$ git push [remote] --all 撤销恢复暂存区的指定文件到工作区1$ git checkout [file] 恢复某个commit的指定文件到暂存区和工作区1$ git checkout [commit] [file] 恢复暂存区的所有文件到工作区1$ git checkout 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变1$ git reset [file] 重置暂存区与工作区，与上一次commit保持一致1$ git reset --hard 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变1$ git reset [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致1$ git reset --hard [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变1$ git reset --keep [commit] 新建一个commit，用来撤销指定commit1$ $ git revert [commit] 暂时将未提交的变化移除，稍后再移入1$ git stash 发布生成一个可供发布的压缩包1$ git archive","categories":[{"name":"编程","slug":"编程","permalink":"https://luluminusone.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"前端入门之路","slug":"Web-Software-Engineer-begin","date":"2022-07-21T02:19:06.355Z","updated":"2022-07-21T06:37:41.977Z","comments":true,"path":"2022/07/21/Web-Software-Engineer-begin/","link":"","permalink":"https://luluminusone.github.io/2022/07/21/Web-Software-Engineer-begin/","excerpt":"","text":"语法html(超文本标记语言)菜鸟教程: https://www.runoob.com/html/html-tutorial.htmlMDN教程: https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Introduction_to_HTML/Getting_started CSScss基础语法: w3c css 基础语法css进阶语法-scss: http://www.sass.hk/ JS(javascript)ES5基础语法: https://www.w3school.com.cn/js/index.aspES6基础语法: 阮一峰ES6教程 1熟悉ES5再学习 js进阶语法-typescript: https://www.tslang.cn/docs/home.html 1熟悉ES6基础再作研究 前端框架vuevuejs(2.x): https://cn.vuejs.org/v2/guide/vuejs(3.x): https://v3.cn.vuejs.org/guide/introduction.htmlvue-router: vue路由管理工具 https://router.vuejs.org/zh/vue脚手架工具: https://cli.vuejs.org/zh/guide/ 用这个工具可以直接创建vue项目 12vue脚手架已经集成了wepack、less、scss、vue-router、vuex等依赖包，前期用vue-cli创建项目即可开发，开箱即用，等熟悉了再一一研究以上开发工具 前端工程开发依赖包管理npm前端开发依赖包管理工具: https://www.npmjs.cn/node.js下载网址: https://nodejs.org/zh-cn/ 项目打包工具webpack https://webpack.docschina.org/concepts/ 前期用vue脚手架开发项目即可，熟悉用法后再深入研究 代码管理git，廖雪峰教程: https://www.liaoxuefeng.com/wiki/896043488029600github代码仓库: https://github.com/gitee代码仓库（码云）: https://gitee.com/ 以上为学习资料","categories":[{"name":"编程","slug":"编程","permalink":"https://luluminusone.github.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"如何用Hexo和GitHub Page搭建个人blog","slug":"how-to-create-blog","date":"2022-07-20T02:23:21.071Z","updated":"2022-07-21T06:37:06.999Z","comments":true,"path":"2022/07/20/how-to-create-blog/","link":"","permalink":"https://luluminusone.github.io/2022/07/20/how-to-create-blog/","excerpt":"","text":"其实写这篇文章缘由是在于对想搭建博客的兄弟姐妹们的一个保姆级教程，hexo是一个容易上手，零成本，搭建操作较简单的工具。 用hexo来搭博客是使用markdown文件来解析，json进行数据存储，不需要数据库去存储数据，文档比较完善，其官方插件较多，可以满足大部分需求，开发过程较轻松，坑不多，建议用hexo来搭博客，今天就把用hexo搭博客的教程呈上，大家一起来动手吧！ 安装Node.js首先你需要安装好Node，hexo需要用到Node的NPM工具，如果没有安装过Node.js的可以去Node官网下载,安装完了用cmd命令查看Node版本。 1node -v 如果出现一下信息，说明安装成功（版本号可以不一致，建议安装最新稳定版本） 1v12.22.9 安装Git当你安装完Node.js之后，还需安装Git，完事之后可用cmd命令查看Git的版本。 1git -v 如果出现一下信息，说明安装成功（版本号可以不一致，建议安装最新稳定版本） 1git version 2.37.1.window.1 安装Hexo脚手架工具如果Git跟Node.js都安装完成后，即可开始！首先，在cmd输入一下命令。 1npm install -g hexo-cli 建立自己的博客选自己喜欢的盘创建一个空白文件夹， 输入以下命令自动生成Hexo博客。 1$ hexo init 部署完成后可在目录看到一下文件 _config.yml #博客配置文件 package.json #模块和依赖项 scaffolds source #文章 _drafts #草稿目录 _posts #发布的文章目录 themes #主题 文件说明_config.yml #Hexo Configuration##Docs: https://hexo.io/docs/configuration.html##Source: https://github.com/hexojs/hexo/ #Siitetitle: 网站标题如：lulu-blogsubtitle: 网站副标题：luludescription: 网站描述： blog for techauthor: 网站作者：lululanguage: 网站的语言timezone: 网站的时间区，默认使用的是电脑的时区#URL##If your site is put in a subdirectory, set url as http://yoursite.com/child and root as ‘&#x2F;child&#x2F;‘url: 网站地址：https://github.com/luluminusone.github.io.gitroot: 网站根目录,建议是用’&#x2F;‘permalink: 文章的永久链接格式，默认就好 :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;permalink_defaults: 永久链接中各部分的默认值，不用填 #Directorysource_dir: 资源文件夹，存放文章用的：sourcepublic_dir: 公共文件夹，用来存放编译之后的文件：publictag_dir: 标签文件夹：tagsarchive_dir: 归档文件夹，也就是你的全部文章生成的目录：archivescategory_dir: 分类文件夹：categoriescode_dir: Include code文件夹：downloads&#x2F;codei18n_dir: 国际化（i18n）文件夹:langskip_render: 需要跳过渲染的文件存放的文件夹 #Writingnew_post_name: :title.md # File name of new postsdefault_layout: 默认文章样式：posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight:enable: trueline_number: trueauto_detect: falsetab_replace: #Home page setting#path: Root path for your blogs index page. (default &#x3D; ‘’)#per_page: Posts displayed per page. (0 &#x3D; disable pagination)#order_by: Posts order. (Order by date descending by default)index_generator:path: ‘’per_page: 每一页显示的文章：10order_by: -date #Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map: #Date &#x2F; Time format##Hexo uses Moment.js to parse and display date##You can customize the date format as defined in##http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss #Pagination##Set per_page to 0 to disable paginationper_page: 10pagination_dir: page #Extensions##Plugins: https://hexo.io/plugins/##Themes: https://hexo.io/themes/theme: 主题：flex-block #Deployment##Docs: https://hexo.io/docs/deployment.htmldeploy:type: gitrepo: https://github.com/luluminusone/luluminusone.github.io.gitbranch: master 写作说完配置文件，就要说一下写作的技巧，使用cmd命令创建一篇文章（当然，你也可以在你自己的编辑器里面，找到source&#x2F;_post&#x2F;这个文件夹去创建md文件用于编写文章） 1hexo new post &#x27;我的第一篇文章&#x27; 以上是用命令行去创建的，用编辑器创建的就不用教了吧，鼠标右键创建即可。 hexo还有一个文件夹是草稿文件夹_draft，可以用理解成私密文章的功能，只要有不想显示的文章但是又不想删除，就可以把文章拖进去_draft文件夹就可以实现隐藏的功能了，也可以用hexo的命令将文章放到草稿文件夹。 编译文章当我们写好文章的时候，需要预览的话，在编辑器的terminal或者cmd命令编写以下指令 1hexo g 或者 hexo generate(二选一) 预览文章1hexo s 或者 hexo server（二选一） 如果需要预览draft文件夹下面的文件，需要在后面加上–draft参数 1hexo s --draft 部署博客当写完文章时，需要对文章编译后上传，部署到GitHub仓库里，我们需要注册一个GitHub账号，建议科学上网去注册，不然太慢了，如果GitHub注册问题无法解决，可以使用国内的码云注册一个仓库，其实相当于国内的GitHub你可以这么理解。在码云创建好仓库之后，将仓库的SSH后面的地址复制到_config.yml文件里，找到以下这个地方，修改一下 #Deployment##Docs: https://hexo.io/docs/deployment.htmldeploy:type: gitrepo: 这里填写为刚复制仓库的SSH地址branch: master 哦对了，对于如何生成SSH公钥我把码云公钥教程也放这里吧，大家不要着急，一步一步来搭建博客不难的。SSH公钥教程,码云写的教程还是比较详细的。 上传项目到了上传项目这一步了，我们需要用到hexo的GitHub插件hexo-deployer-git,首先cmd命令去下载这个插件. 1npm install hexo-deployer-git --save 然后就到了万众瞩目的一步了，输入以下cmd命令即可上传项目了 1hexo d 完成项目！！！大家辛苦了后续补充刚生成的项目主题应该是有很多人不太喜欢的，这里放一个hexo主题网站，大家在里面选自己喜欢的主题，然后可以在GitHub或者码云上clone主题到themes这个文件夹里，网站在这主题。git克隆的指令如下,可以在用cmd命令，也可用git bash here。 1234git clone https://github.com/yscoder/hexo-theme-indigo.git themes/indigo记住，上述指令git clone和网址后的.git themes/(这里是起文件夹名，英文就好，可随便起)是必须要有的，中间的是网址，找到你自己喜欢的主题，在github或码云上搜，然后将搜到的主题仓库网址复制即可到中间即可，纯手打也行。 克隆完成后，在_config.yml文件，找到theme: landscape将他改成你克隆主题的文件夹名字即可，例如一上面为例，改成theme: indigo这里就OK了，然后运行以下指令 123hexo cleanhexo ghexo s 这样就大功告成，如果有些主题部署报错，那就换一个吧，别纠结了，当然，如果有能力会改错修改bug也可以成功用到报错的主题，以上！！","categories":[{"name":"搭建","slug":"搭建","permalink":"https://luluminusone.github.io/categories/%E6%90%AD%E5%BB%BA/"}],"tags":[]},{"title":"Lulu blog for tec","slug":"hello-my-blog","date":"2022-07-19T08:13:28.392Z","updated":"2022-07-21T06:38:08.786Z","comments":true,"path":"2022/07/19/hello-my-blog/","link":"","permalink":"https://luluminusone.github.io/2022/07/19/hello-my-blog/","excerpt":"","text":"记录自己的成长之路，学无止境 其实写blog是对自己在前端学习路上的一个小帮手，因为前端知识很多很多，也算是总结学习成果，加油吧！！！","categories":[{"name":"有感","slug":"有感","permalink":"https://luluminusone.github.io/categories/%E6%9C%89%E6%84%9F/"}],"tags":[]}],"categories":[{"name":"编程","slug":"编程","permalink":"https://luluminusone.github.io/categories/%E7%BC%96%E7%A8%8B/"},{"name":"安利","slug":"安利","permalink":"https://luluminusone.github.io/categories/%E5%AE%89%E5%88%A9/"},{"name":"搭建","slug":"搭建","permalink":"https://luluminusone.github.io/categories/%E6%90%AD%E5%BB%BA/"},{"name":"有感","slug":"有感","permalink":"https://luluminusone.github.io/categories/%E6%9C%89%E6%84%9F/"}],"tags":[]}